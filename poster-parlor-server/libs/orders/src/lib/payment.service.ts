import { Injectable, Logger } from '@nestjs/common';
import { AppConfigService } from '@poster-parlor-api/config';
import { BadRequestException } from '@poster-parlor-api/utils';
import Razorpay from 'razorpay';
import crypto from 'crypto';

// DTO interface for creating a payment order - defines the structure of data needed to create an order
export interface CreatePaymentOrderDto {
  amount: number; // Amount in paise (INR * 100) - Razorpay requires amount in smallest currency unit
  currency?: string; // Optional currency code (defaults to INR if not provided)
  receipt: string; // Unique receipt identifier for this order - useful for tracking
  notes?: Record<string, string>; // Optional key-value pairs for storing additional information
}

// Interface representing the Razorpay order response structure
export interface RazorpayOrder {
  id: string; // Unique order ID generated by Razorpay
  entity: string; // Entity type - will be "order"
  amount: number; // Total order amount in paise
  amount_paid: number; // Amount that has been paid so far
  amount_due: number; // Amount still pending to be paid
  currency: string; // Currency code (e.g., INR, USD)
  receipt: string; // The receipt ID we provided when creating the order
  status: string; // Order status (created, attempted, paid, etc.)
  created_at: number; // Unix timestamp of when the order was created
}

// DTO interface for verifying payment after user completes payment
export interface VerifyPaymentDto {
  razorpay_order_id: string; // The order ID that was created earlier
  razorpay_payment_id: string; // The payment ID generated after successful payment
  razorpay_signature: string; // HMAC signature sent by Razorpay to verify authenticity
}

// Interface for the payment verification result that we return
export interface PaymentVerificationResult {
  isValid: boolean; // Whether the signature verification passed
  orderId: string; // The order ID that was verified
  paymentId: string; // The payment ID that was verified
}

// Mark this class as a NestJS service that can be injected into other classes
@Injectable()
export class PaymentService {
  // Private instance of Razorpay SDK for making API calls
  private razorpay: Razorpay;
  
  // Logger instance for logging service activities and errors
  private readonly logger = new Logger(PaymentService.name);

  // Constructor that initializes the service with config dependency injection
  constructor(private readonly configService: AppConfigService) {
    // Extract Razorpay credentials from configuration service
    const { razorpayKeyId, razorpayKeySecret } =
      this.configService.paymentConfig;
    
    // Initialize Razorpay instance with API credentials
    this.razorpay = new Razorpay({
      key_id: razorpayKeyId, // Public key ID for Razorpay API authentication
      key_secret: razorpayKeySecret, // Secret key for Razorpay API authentication
    });
    
    // Log successful initialization for debugging purposes
    this.logger.log('Razorpay payment service initialized');
  }

  /**
   * Get Razorpay Key ID for frontend
   * This public key is safe to expose to the client-side code
   */
  getKeyId(): string {
    // Return the public Razorpay key ID that frontend needs for checkout
    return this.configService.paymentConfig.razorpayKeyId;
  }

  /**
   * Create a Razorpay order for payment
   * This order must be created before showing the payment interface to user
   * @param dto - Payment order details
   * @returns Razorpay order object
   */
  async createOrder(dto: CreatePaymentOrderDto): Promise<RazorpayOrder> {
    try {
      // Prepare options object according to Razorpay API specification
      const options = {
        amount: Math.round(dto.amount), // Round amount to avoid decimal issues (should already be in paise)
        currency: dto.currency || 'INR', // Use provided currency or default to Indian Rupees
        receipt: dto.receipt, // Unique receipt identifier for tracking this transaction
        notes: dto.notes || {}, // Additional metadata or empty object if not provided
      };

      // Log the order creation request for debugging and audit trail
      this.logger.debug(
        `Creating Razorpay order: ${JSON.stringify(options, null, 2)}`
      );

      // Make API call to Razorpay to create the order
      const order = (await this.razorpay.orders.create(
        options
      )) as RazorpayOrder;

      // Log successful order creation with the order ID
      this.logger.log(`Razorpay order created: ${order.id}`);
      
      // Return the created order object to the caller
      return order;
    } catch (error) {
      // Log the error with details for debugging
      this.logger.error('Failed to create Razorpay order', error);
      
      // Throw a user-friendly error message (hides internal error details)
      throw new BadRequestException(
        'Failed to create payment order. Please try again.'
      );
    }
  }

  /**
   * Verify payment signature from Razorpay callback
   * This is crucial for security - ensures the payment notification is genuinely from Razorpay
   * @param dto - Payment verification data
   * @returns Verification result
   */
  verifyPaymentSignature(dto: VerifyPaymentDto): PaymentVerificationResult {
    // Destructure the payment verification data from the DTO
    const { razorpay_order_id, razorpay_payment_id, razorpay_signature } = dto;

    // Get the secret key from configuration for signature verification
    const { razorpayKeySecret } = this.configService.paymentConfig;

    // Create the expected signature string by concatenating order ID and payment ID
    const body = razorpay_order_id + '|' + razorpay_payment_id;
    
    // Generate HMAC SHA256 hash using our secret key and the body string
    const expectedSignature = crypto
      .createHmac('sha256', razorpayKeySecret) // Create HMAC with SHA256 algorithm
      .update(body.toString()) // Update HMAC with the concatenated string
      .digest('hex'); // Get the final hash in hexadecimal format

    // Compare our generated signature with the one Razorpay sent
    const isValid = expectedSignature === razorpay_signature;

    // Log successful verification
    if (isValid) {
      this.logger.log(
        `Payment verified successfully: ${razorpay_payment_id} for order ${razorpay_order_id}`
      );
    } else {
      // Log failed verification as a warning (potential security issue)
      this.logger.warn(
        `Payment verification failed for order ${razorpay_order_id}`
      );
    }

    // Return verification result with relevant IDs for further processing
    return {
      isValid, // Boolean indicating if signature is valid
      orderId: razorpay_order_id, // The verified order ID
      paymentId: razorpay_payment_id, // The verified payment ID
    };
  }

  /**
   * Fetch payment details from Razorpay
   * Useful for getting complete payment information after verification
   * @param paymentId - Razorpay payment ID
   */
  async getPaymentDetails(paymentId: string) {
    try {
      // Make API call to Razorpay to fetch complete payment details
      const payment = await this.razorpay.payments.fetch(paymentId);
      
      // Return the payment details object
      return payment;
    } catch (error) {
      // Log the error with payment ID for debugging
      this.logger.error(`Failed to fetch payment details: ${paymentId}`, error);
      
      // Throw user-friendly error message
      throw new BadRequestException('Failed to fetch payment details');
    }
  }
}
